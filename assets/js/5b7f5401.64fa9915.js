"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2355],{5201(r,e,n){n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"t-lib/common-patterns","title":"Common Patterns & Examples","description":"This guide covers common use cases and best practices for working with T_Lib in real robot code.","source":"@site/docs/t-lib/common-patterns.md","sourceDirName":"t-lib","slug":"/t-lib/common-patterns","permalink":"/T_Lib/docs/t-lib/common-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/Brody9185/T_Lib/tree/main/website/docs/t-lib/common-patterns.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","next":{"title":"FAQ & Troubleshooting","permalink":"/T_Lib/docs/t-lib/faq-troubleshooting"}}');var o=n(4848),s=n(8453);const i={},a="Common Patterns & Examples",l={},d=[{value:"Basic Motor Control",id:"basic-motor-control",level:2},{value:"Simple Single Motor",id:"simple-single-motor",level:3},{value:"Motor with Configuration",id:"motor-with-configuration",level:3},{value:"Drivetrain Patterns",id:"drivetrain-patterns",level:2},{value:"Tank Drive with Motor Groups",id:"tank-drive-with-motor-groups",level:3},{value:"Tank Drive with Slow Mode",id:"tank-drive-with-slow-mode",level:3},{value:"Subsystem Architecture",id:"subsystem-architecture",level:2},{value:"Motor Subsystem Class",id:"motor-subsystem-class",level:3},{value:"Advanced Control Patterns",id:"advanced-control-patterns",level:2},{value:"PID Tuning with Live Adjustment",id:"pid-tuning-with-live-adjustment",level:3},{value:"Load Detection and Response",id:"load-detection-and-response",level:3},{value:"Autonomous Patterns",id:"autonomous-patterns",level:2},{value:"Time-Based Movement",id:"time-based-movement",level:3},{value:"Encoder-Based Movement",id:"encoder-based-movement",level:3},{value:"Troubleshooting Patterns",id:"troubleshooting-patterns",level:2},{value:"Debug Output Macro",id:"debug-output-macro",level:3},{value:"Monitoring Multiple Motors",id:"monitoring-multiple-motors",level:3},{value:"Best Practices",id:"best-practices",level:2}];function c(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"common-patterns--examples",children:"Common Patterns & Examples"})}),"\n",(0,o.jsx)(e.p,{children:"This guide covers common use cases and best practices for working with T_Lib in real robot code."}),"\n",(0,o.jsx)(e.h2,{id:"basic-motor-control",children:"Basic Motor Control"}),"\n",(0,o.jsx)(e.h3,{id:"simple-single-motor",children:"Simple Single Motor"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include "main.h"\r\n#include "T_Lib/api.hpp"\r\n\r\nvoid opcontrol() {\r\n    T_Lib::T_Motor motor(1);\r\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\r\n    \r\n    while (true) {\r\n        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {\r\n            motor.setTargetRPM(600);\r\n        } else {\r\n            motor.stop();\r\n        }\r\n        \r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"motor-with-configuration",children:"Motor with Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'void opcontrol() {\r\n    T_Lib::T_Motor motor(1, T_Lib::util::Aliases::Blue);\r\n    \r\n    // Configure motor behavior\r\n    motor.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    motor.setBrakeMode(T_Lib::util::Aliases::Hold);\r\n    motor.setLoadCompensation(true, 5.0, 15);\r\n    motor.setMinTorque(true, 1200, 600);\r\n    \r\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\r\n    \r\n    while (true) {\r\n        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {\r\n            motor.setTargetPercent(75);  // 75% power\r\n        } else {\r\n            motor.stop();\r\n        }\r\n        \r\n        // Print telemetry\r\n        printf("RPM: %f, Temp: %f C\\n", motor.getRPM(), motor.getTemperature());\r\n        \r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"drivetrain-patterns",children:"Drivetrain Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"tank-drive-with-motor-groups",children:"Tank Drive with Motor Groups"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include "main.h"\r\n#include "T_Lib/api.hpp"\r\n\r\nvoid opcontrol() {\r\n    // Create motor groups for left and right sides\r\n    T_MotorGroup left_motors({1, 2, 3});\r\n    T_MotorGroup right_motors({4, 5, 6});\r\n    \r\n    // Configure both sides identically\r\n    for (auto* group : {&left_motors, &right_motors}) {\r\n        group->setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n        group->setBrakeMode(T_Lib::util::Aliases::Hold);\r\n        group->setLoadCompensation(true, 5.0);\r\n        group->setMinTorque(true, 1200, 600);\r\n    }\r\n    \r\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\r\n    \r\n    while (true) {\r\n        // Arcade drive\r\n        int forward = master.get_analog(ANALOG_LEFT_Y);\r\n        int turn = master.get_analog(ANALOG_RIGHT_X);\r\n        \r\n        left_motors.setTargetPercent(forward + turn);\r\n        right_motors.setTargetPercent(forward - turn);\r\n        \r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"tank-drive-with-slow-mode",children:"Tank Drive with Slow Mode"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'void opcontrol() {\r\n    T_MotorGroup left_motors({1, 2, 3});\r\n    T_MotorGroup right_motors({4, 5, 6});\r\n    \r\n    // Configure groups\r\n    left_motors.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    right_motors.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    left_motors.setBrakeMode(T_Lib::util::Aliases::Hold);\r\n    right_motors.setBrakeMode(T_Lib::util::Aliases::Hold);\r\n    \r\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\r\n    bool slow_mode = false;\r\n    \r\n    while (true) {\r\n        // Toggle slow mode\r\n        if (master.get_digital_new_press(pros::E_CONTROLLER_DIGITAL_X)) {\r\n            slow_mode = !slow_mode;\r\n        }\r\n        \r\n        int forward = master.get_analog(ANALOG_LEFT_Y);\r\n        int turn = master.get_analog(ANALOG_RIGHT_X);\r\n        \r\n        // Apply slow mode multiplier\r\n        if (slow_mode) {\r\n            forward *= 0.6;\r\n            turn *= 0.6;\r\n        }\r\n        \r\n        left_motors.setTargetPercent(forward + turn);\r\n        right_motors.setTargetPercent(forward - turn);\r\n        \r\n        printf("%s Mode\\n", slow_mode ? "SLOW" : "NORMAL");\r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"subsystem-architecture",children:"Subsystem Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"motor-subsystem-class",children:"Motor Subsystem Class"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include "main.h"\r\n#include "T_Lib/api.hpp"\r\n\r\nclass IntakeSystem {\r\nprivate:\r\n    T_Lib::T_Motor intake_motor;\r\n    bool running = false;\r\n    \r\npublic:\r\n    IntakeSystem(int port) \r\n        : intake_motor(port, T_Lib::util::Aliases::Green) {\r\n        // Configure motor\r\n        intake_motor.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n        intake_motor.setLoadeCompensation(true);\r\n        intake_motor.setBrakeMode(T_Lib::util::Aliases::Coast);\r\n    }\r\n    \r\n    void start() {\r\n        intake_motor.setTargetRPM(200);\r\n        running = true;\r\n    }\r\n    \r\n    void reverse() {\r\n        intake_motor.setTargetRPM(-200);\r\n        running = true;\r\n    }\r\n    \r\n    void stop() {\r\n        intake_motor.stop();\r\n        running = false;\r\n    }\r\n    \r\n    bool isRunning() const {\r\n        return running;\r\n    }\r\n};\r\n\r\nclass Drivetrain {\r\nprivate:\r\n    T_MotorGroup left_motors;\r\n    T_MotorGroup right_motors;\r\n    \r\npublic:\r\n    Drivetrain(const std::vector<int>& left_ports, \r\n               const std::vector<int>& right_ports)\r\n        : left_motors(left_ports), right_motors(right_ports) {\r\n        \r\n        // Configure\r\n        left_motors.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n        right_motors.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n        \r\n        left_motors.setBrakeMode(T_Lib::util::Aliases::Hold);\r\n        right_motors.setBrakeMode(T_Lib::util::Aliases::Hold);\r\n    }\r\n    \r\n    void arcadeDrive(double forward, double turn) {\r\n        left_motors.setTargetPercent(forward + turn);\r\n        right_motors.setTargetPercent(forward - turn);\r\n    }\r\n    \r\n    void stop() {\r\n        left_motors.stop();\r\n        right_motors.stop();\r\n    }\r\n    \r\n    double getLeftRPM() const { return left_motors.getAverageRPM(); }\r\n    double getRightRPM() const { return right_motors.getAverageRPM(); }\r\n};\r\n\r\n// Global subsystem instances\r\nDrivetrain g_drivetrain({1, 2, 3}, {4, 5, 6});\r\nIntakeSystem g_intake(7);\r\n\r\nvoid opcontrol() {\r\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\r\n    \r\n    while (true) {\r\n        // Intake control\r\n        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {\r\n            g_intake.start();\r\n        } else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {\r\n            g_intake.reverse();\r\n        } else {\r\n            g_intake.stop();\r\n        }\r\n        \r\n        // Drive control\r\n        int forward = master.get_analog(ANALOG_LEFT_Y);\r\n        int turn = master.get_analog(ANALOG_RIGHT_X);\r\n        g_drivetrain.arcadeDrive(forward, turn);\r\n        \r\n        // Telemetry\r\n        printf("L: %.0f, R: %.0f | Intake: %s\\n",\r\n               g_drivetrain.getLeftRPM(),\r\n               g_drivetrain.getRightRPM(),\r\n               g_intake.isRunning() ? "ON" : "OFF");\r\n        \r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"advanced-control-patterns",children:"Advanced Control Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"pid-tuning-with-live-adjustment",children:"PID Tuning with Live Adjustment"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'void tuneMotorPID() {\r\n    T_Lib::T_Motor motor(1);\r\n    pros::Controller master(pros::E_CONTROLLER_MASTER);\r\n    \r\n    double kv = 0.05;\r\n    double kp = 0.1;\r\n    double ki = 0.001;\r\n    double kd = 0.05;\r\n    \r\n    motor.setLowConstants(kv, kp, ki, kd);\r\n    \r\n    while (true) {\r\n        // Adjust constants in real-time\r\n        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {\r\n            kp += 0.01;\r\n            motor.setLowConstants(kv, kp, ki, kd);\r\n            printf("KP: %.4f\\n", kp);\r\n            pros::delay(100);\r\n        }\r\n        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_B)) {\r\n            kp -= 0.01;\r\n            motor.setLowConstants(kv, kp, ki, kd);\r\n            printf("KP: %.4f\\n", kp);\r\n            pros::delay(100);\r\n        }\r\n        \r\n        // Run motor at target\r\n        motor.setTargetRPM(600);\r\n        printf("RPM: %.1f\\n", motor.getRPM());\r\n        \r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"load-detection-and-response",children:"Load Detection and Response"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include "main.h"\r\n#include "T_Lib/api.hpp"\r\n\r\nclass LoadSensitiveMotor {\r\nprivate:\r\n    T_Lib::T_Motor motor;\r\n    bool overloaded = false;\r\n    \r\npublic:\r\n    LoadSensitiveMotor(int port) \r\n        : motor(port) {\r\n        motor.setLoadCompensation(true, 5.0, 15);\r\n        motor.setMinTorque(true, 1200, 600);\r\n    }\r\n    \r\n    void setTargetRPM(double rpm) {\r\n        motor.setTargetRPM(rpm);\r\n    }\r\n    \r\n    void update() {\r\n        // Check if motor is under heavy load\r\n        // High current draw with low RPM indicates load\r\n        int voltage = motor.getVoltage();\r\n        double rpm = motor.getRPM();\r\n        \r\n        if (voltage > 11000 && rpm < 100) {  // Near max voltage, very slow\r\n            overloaded = true;\r\n        } else {\r\n            overloaded = false;\r\n        }\r\n    }\r\n    \r\n    bool isOverloaded() const {\r\n        return overloaded;\r\n    }\r\n    \r\n    double getTemperature() const {\r\n        return motor.getTemperature();\r\n    }\r\n};\r\n\r\nvoid opcontrol() {\r\n    LoadSensitiveMotor motor(1);\r\n    \r\n    while (true) {\r\n        motor.setTargetRPM(600);\r\n        motor.update();\r\n        \r\n        if (motor.isOverloaded()) {\r\n            printf("\u26a0\ufe0f MOTOR OVERLOADED! Temp: %.1f C\\n", motor.getTemperature());\r\n        }\r\n        \r\n        pros::delay(20);\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"autonomous-patterns",children:"Autonomous Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"time-based-movement",children:"Time-Based Movement"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"void autonomous() {\r\n    T_MotorGroup left({1, 2, 3});\r\n    T_MotorGroup right({4, 5, 6});\r\n    \r\n    left.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    right.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    \r\n    // Drive forward for 2 seconds\r\n    left.setTargetPercent(75);\r\n    right.setTargetPercent(75);\r\n    pros::delay(2000);\r\n    \r\n    // Turn right for 1 second\r\n    left.setTargetPercent(75);\r\n    right.setTargetPercent(-75);\r\n    pros::delay(1000);\r\n    \r\n    // Stop\r\n    left.stop();\r\n    right.stop();\r\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"encoder-based-movement",children:"Encoder-Based Movement"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"void driveDistance(T_MotorGroup& left, T_MotorGroup& right, \r\n                    double distance_inches, double power_percent) {\r\n    using namespace T_Lib::util;\r\n    \r\n    // Reset encoders\r\n    left.resetPositions();\r\n    right.resetPositions();\r\n    \r\n    double wheel_diameter = Wheel_Size::Trac_4in;\r\n    double circumference = M_PI * wheel_diameter;\r\n    double target_counts = (distance_inches / circumference) * 360.0;\r\n    \r\n    // Drive at target power\r\n    left.setTargetPercent(power_percent);\r\n    right.setTargetPercent(power_percent);\r\n    \r\n    // Wait until both sides exceed target distance\r\n    while (true) {\r\n        double left_distance = left.getMotors()[0]->getPosition();\r\n        double right_distance = right.getMotors()[0]->getPosition();\r\n        \r\n        if (left_distance > target_counts && right_distance > target_counts) {\r\n            break;\r\n        }\r\n        \r\n        pros::delay(20);\r\n    }\r\n    \r\n    left.stop();\r\n    right.stop();\r\n}\r\n\r\nvoid autonomous() {\r\n    T_MotorGroup left({1, 2, 3});\r\n    T_MotorGroup right({4, 5, 6});\r\n    \r\n    left.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    right.setDualConstants(0.05, 0.1, 0.05, 0.05);\r\n    \r\n    // Drive forward 24 inches\r\n    driveDistance(left, right, 24.0, 75.0);\r\n    \r\n    // Turn (spin)\r\n    left.setTargetPercent(75);\r\n    right.setTargetPercent(-75);\r\n    pros::delay(800);  // Adjust time for 90-degree turn\r\n    \r\n    left.stop();\r\n    right.stop();\r\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-patterns",children:"Troubleshooting Patterns"}),"\n",(0,o.jsx)(e.h3,{id:"debug-output-macro",children:"Debug Output Macro"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#define DEBUG_PRINT(...) do { \\\r\n    printf(__VA_ARGS__); \\\r\n    printf("\\n"); \\\r\n} while(0)\r\n\r\nvoid debugMotor(T_Lib::T_Motor& motor, const char* name) {\r\n    DEBUG_PRINT("%s - RPM: %.1f | Temp: %.1f\xb0C | Voltage: %d mV",\r\n                name, motor.getRPM(), motor.getTemperature(), motor.getVoltage());\r\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"monitoring-multiple-motors",children:"Monitoring Multiple Motors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'void monitorDrivetrain(T_MotorGroup& left, T_MotorGroup& right) {\r\n    printf("LEFT MOTORS:\\n");\r\n    for (size_t i = 0; i < left.getMotors().size(); ++i) {\r\n        auto& motor = left.getMotors()[i];\r\n        printf("  [%zu] RPM: %.1f, Temp: %.1f C\\n", \r\n               i, motor->getRPM(), motor->getTemperature());\r\n    }\r\n    \r\n    printf("RIGHT MOTORS:\\n");\r\n    for (size_t i = 0; i < right.getMotors().size(); ++i) {\r\n        auto& motor = right.getMotors()[i];\r\n        printf("  [%zu] RPM: %.1f, Temp: %.1f C\\n", \r\n               i, motor->getRPM(), motor->getTemperature());\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Always configure motors early"}),": Set PID constants, brake mode, and protection features during initialization"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use motor groups for synchronized control"}),": Reduces code duplication and ensures consistent behavior"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Implement telemetry"}),": Use periodic debug output to monitor motor health and performance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Test PID constants"}),": Tune dual constants for your specific gearset and load"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use load compensation"}),": Enables motors to maintain speed under variable loads"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Apply slew limiting"}),": Reduces wheel slip and mechanical stress in rapid acceleration"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Organize code with subsystem classes"}),": Makes autonomous and teleop more manageable"]}),"\n"]})]})}function u(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(c,{...r})}):c(r)}},8453(r,e,n){n.d(e,{R:()=>i,x:()=>a});var t=n(6540);const o={},s=t.createContext(o);function i(r){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function a(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:i(r.components),t.createElement(s.Provider,{value:e},r.children)}}}]);